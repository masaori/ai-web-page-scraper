import path from 'path'
import fs from 'fs'
import { getEntityDefinitions } from 'ast-to-entity-definitions/bin/adapter/entry-points/function'
import { camelCase, pascalCase } from 'change-case'

export const generateCheckEntityTypes = async () => {
  const pathToEntitiesDirectory = path.join(__dirname, '..', 'src', 'domain', 'entities')
  const pathToOutputDirectory = path.join(__dirname, '..', 'src', 'domain', '_shared', '_gen', 'checkEntityTypes')

  if (!fs.existsSync(pathToOutputDirectory)) {
    throw new Error(`[generateCheckEntityTypes] pathToOutputDirectory does not exist: ${pathToOutputDirectory}`)
  }
  // Delete all files in pathToOutputDirectory first
  fs.readdirSync(pathToOutputDirectory).forEach((fileOrDir) => {
    // check if directory
    if (fs.lstatSync(path.join(pathToOutputDirectory, fileOrDir)).isDirectory()) {
      fs.rmSync(fileOrDir, { recursive: true, force: true })
    } else {
      fs.unlinkSync(path.join(pathToOutputDirectory, fileOrDir))
    }
  })

  const entityDefinitions = await getEntityDefinitions(pathToEntitiesDirectory)

  // const identifiableEntities = entityDefinitions.filter((entityDefinition) => {
  //   return entityDefinition.properties.find((property) => property.name === 'id')
  // })
  const nonIdentifiableEntities = entityDefinitions.filter((entityDefinition) => {
    return !entityDefinition.properties.find((property) => property.name === 'id')
  })

  for (const entityDefinition of entityDefinitions) {
    // const uniqueReferrencingEntities = identifiableEntities.filter((candidateEntityDefinition) => {
    //   return candidateEntityDefinition.properties.find((property) => property.isReference && property.isUnique && property.targetEntityDefinitionName === entityDefinition.name)
    // })
    // const nonUniqueReferrencingEntities = identifiableEntities.filter((candidateEntityDefinition) => {
    //   return candidateEntityDefinition.properties.find((property) => property.isReference && !property.isUnique && property.targetEntityDefinitionName === entityDefinition.name)
    // })
    const subTypeEntities = nonIdentifiableEntities.filter((candidateEntityDefinition) => {
      return candidateEntityDefinition.properties.find((property) => property.isReference && property.isUnique && property.targetEntityDefinitionName === entityDefinition.name)
    })

    const singleResult = `// This file is generated by scripts/generateCheckEntityTypes.ts
    import { ${pascalCase(entityDefinition.name)} } from '../../../../entities/${pascalCase(entityDefinition.name)}'

    export const checkEntityType${pascalCase(entityDefinition.name)} = (entity: unknown): entity is ${pascalCase(entityDefinition.name)} => {
      if (typeof entity !== 'object' || entity === null) {
        return false
      }
      if (
        ${entityDefinition.properties
          .map((property) => {
            const checkExistance = `!('${camelCase(property.name)}' in entity)`
            let checkType: string

            if (property.isReference) {
              if (property.isNullable) {
                checkType = `entity.${camelCase(property.name)} !== null && typeof entity.${camelCase(property.name)} !== 'string'`
              } else {
                checkType = `typeof entity.${camelCase(property.name)} !== 'string'`
              }
            } else {
              const checkIsNull = property.isNullable ? `entity.${camelCase(property.name)} !== null && ` : ''
              const checkIsPropertyType = (() => {
                switch (property.propertyType) {
                  case 'string':
                    if (property.acceptableValues) {
                      console.log(`[generateCheckEntityTypes] property.acceptableValues:${entityDefinition.name}.${property.name}:${JSON.stringify(property.acceptableValues)}`)

                      return `!(${property.acceptableValues.map((value) => `entity.${camelCase(property.name)} === '${value}'`).join(' || ')})`
                    } else {
                      return `typeof entity.${camelCase(property.name)} !== 'string'`
                    }
                  default:
                    return `typeof entity.${camelCase(property.name)} !== '${property.propertyType}'`
                }
              })()

              checkType = `${checkIsNull}${checkIsPropertyType}`
            }

            return `(${checkExistance} || ${checkType})`
          })
          .join(' ||\n        ')}
      ) {
        // console.log(\`[checkEntityType${pascalCase(entityDefinition.name)}] entity is not ${pascalCase(entityDefinition.name)}: \${JSON.stringify(entity)}\`)
        return false
      }
      return true
    }
    `

    const listResult = `// This file is generated by scripts/generateCheckEntityTypes.ts
    import { ${pascalCase(entityDefinition.name)} } from '../../../../entities/${pascalCase(entityDefinition.name)}'
    import { checkEntityType${pascalCase(entityDefinition.name)} } from '../single/checkEntityType${pascalCase(entityDefinition.name)}'

    export const checkEntityType${pascalCase(entityDefinition.name)}List = (entity: unknown): entity is ${pascalCase(entityDefinition.name)}[] => {
      if (typeof entity !== 'object' || entity === null) {
        return false
      }

      if (!Array.isArray(entity)) {
        return false
      }

      for (const el of entity) {
        if (!checkEntityType${pascalCase(entityDefinition.name)}(el)) {
          return false
        }
      }

      return true
    }
    `

    const withAssociationResult = `// This file is generated by scripts/generateCheckEntityTypes.ts
    import { ${pascalCase(entityDefinition.name)}WithAssociation } from '../../../../entities/_gen/${pascalCase(entityDefinition.name)}WithAssociation'
    import { checkEntityType${pascalCase(entityDefinition.name)} } from '../single/checkEntityType${pascalCase(entityDefinition.name)}'
    ${subTypeEntities
      .map((subTypeEntity) => `import { checkEntityType${pascalCase(subTypeEntity.name)}WithAssociation } from '../withAssociation/checkEntityType${pascalCase(subTypeEntity.name)}WithAssociation'`)
      .join('\n')}

    export const checkEntityType${pascalCase(entityDefinition.name)}WithAssociation = (entity: unknown): entity is ${pascalCase(entityDefinition.name)}WithAssociation => {
      if (typeof entity !== 'object' || entity === null) {
        return false
      }

      if (!checkEntityType${pascalCase(entityDefinition.name)}(entity)) {
        return false
      }

      ${
        subTypeEntities.length > 0
          ? `
      if (!(
        ${subTypeEntities
          .map((subTypeEntity) => {
            return `checkEntityType${pascalCase(subTypeEntity.name)}WithAssociation(entity)`
          })
          .join(' ||\n        ')}
      )) {
        return false
      }
      `
          : ''
      }

      return true
    }
    `

    const withAssociationListResult = `// This file is generated by scripts/generateCheckEntityTypes.ts
    import { ${pascalCase(entityDefinition.name)}WithAssociation } from '../../../../entities/_gen/${pascalCase(entityDefinition.name)}WithAssociation'
    import { checkEntityType${pascalCase(entityDefinition.name)}WithAssociation } from '../withAssociation/checkEntityType${pascalCase(entityDefinition.name)}WithAssociation'

    export const checkEntityType${pascalCase(entityDefinition.name)}WithAssociationList = (entity: unknown): entity is ${pascalCase(entityDefinition.name)}WithAssociation[] => {
      if (typeof entity !== 'object' || entity === null) {
        return false
      }

      if (!Array.isArray(entity)) {
        return false
      }

      for (const el of entity) {
        if (!checkEntityType${pascalCase(entityDefinition.name)}WithAssociation(el)) {
          return false
        }
      }

      return true
    }
    `

    fs.writeFileSync(path.join(pathToOutputDirectory, 'single', `checkEntityType${pascalCase(entityDefinition.name)}.ts`), singleResult)
    fs.writeFileSync(path.join(pathToOutputDirectory, 'list', `checkEntityType${pascalCase(entityDefinition.name)}List.ts`), listResult)
    fs.writeFileSync(path.join(pathToOutputDirectory, 'withAssociation', `checkEntityType${pascalCase(entityDefinition.name)}WithAssociation.ts`), withAssociationResult)
    fs.writeFileSync(path.join(pathToOutputDirectory, 'withAssociationList', `checkEntityType${pascalCase(entityDefinition.name)}WithAssociationList.ts`), withAssociationListResult)
  }
}

generateCheckEntityTypes().catch((error) => {
  console.error(error)
  process.exit(1)
})
