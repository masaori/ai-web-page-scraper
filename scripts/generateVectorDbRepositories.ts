import path from 'path'
import fs from 'fs'
import { getEntityDefinitions } from 'ast-to-entity-definitions/bin/adapter/entry-points/function'
import { camelCase, pascalCase, snakeCase } from 'change-case'
import { excludeNull } from '../src/_shared/array'

export const generateVectorDbRepositories = async () => {
  const pathToEntitiesDirectory = path.join(__dirname, '..', 'src', 'domain', 'entities')
  const pathToOutputDirectory = path.join(__dirname, '..', 'src', 'adapter', 'repositories', 'vectorDb', '_gen')

  if (!fs.existsSync(pathToOutputDirectory)) {
    throw new Error(`[generateVectorDbRepositories] pathToOutputDirectory does not exist: ${pathToOutputDirectory}`)
  }
  // Delete all files in pathToOutputDirectory first
  fs.readdirSync(pathToOutputDirectory).forEach((file) => {
    fs.unlinkSync(path.join(pathToOutputDirectory, file))
  })

  const entityDefinitions = await getEntityDefinitions(pathToEntitiesDirectory)

  for (const entityDefinition of entityDefinitions) {
    const primaryKeyName = (() => {
      if (entityDefinition.properties.find((property) => property.name === 'id')) {
        return 'id'
      }

      const uniqueReferenceProperty = entityDefinition.properties.find((property) => property.isReference && property.isUnique)

      if (uniqueReferenceProperty) {
        return uniqueReferenceProperty.name
      }

      throw new Error(`[generateVectorDbRepositories] Could not find primary key for ${pascalCase(entityDefinition.name)}`)
    })()

    const result = `// This file is generated by scripts/generateVectorDbRepositories.ts
    import { ${pascalCase(entityDefinition.name)} } from '../../../../domain/entities/${pascalCase(entityDefinition.name)}'
    import { QdrantClient } from '../../../_shared/QdrantClient'
    import { OpenAiClient } from '../../../_shared/OpenAiClient'
    import { VectorDbRepository } from '../_shared/VectorDbRepository'
    /* eslint-disable @typescript-eslint/no-unused-vars, unused-imports/no-unused-imports-ts */
    import { PromisedResult, UnknownRuntimeError, unknownRuntimeError } from '../../../../_shared/error'
    import { Ok } from '@sniptt/monads'
    /* eslint-enable @typescript-eslint/no-unused-vars, unused-imports/no-unused-imports-ts */


    const qdrantCollectionName = '${snakeCase(entityDefinition.name)}'
    const is${pascalCase(entityDefinition.name)} = (entity: unknown): entity is ${pascalCase(entityDefinition.name)} => {
      return (
        typeof entity === 'object' &&
        entity !== null &&
        ${entityDefinition.properties
          .map((property) => {
            const typeName = property.isReference ? 'string' : property.propertyType

            if (property.isNullable) {
              return `'${property.name}' in entity && (typeof entity.${property.name} === '${typeName}' || entity.${property.name} === null)`
            } else {
              return `'${property.name}' in entity && typeof entity.${property.name} === '${typeName}'`
            }
          })
          .join(' &&\n        ')}
      )
    }

    export class VectorDb${pascalCase(entityDefinition.name)}Repository extends VectorDbRepository<
      '${primaryKeyName}',
      ${pascalCase(entityDefinition.name)}
    > {
      constructor(qdrantClient: QdrantClient, openAiClient: OpenAiClient) {
        super('${primaryKeyName}', qdrantCollectionName, is${pascalCase(entityDefinition.name)}, qdrantClient, openAiClient)
      }

      ${excludeNull(
        entityDefinition.properties.map((property) => {
          if (property.name === primaryKeyName) {
            const methodName = `getBy${pascalCase(property.name)}`

            return `
            ${methodName} = async (${property.name}: string): PromisedResult<${pascalCase(entityDefinition.name)} | null, UnknownRuntimeError> => this.getByPrimaryKey(${property.name})
            `
          }

          if (property.isReference) {
            const methodName = property.isUnique ? `getBy${pascalCase(property.name)}` : `getAllBy${pascalCase(property.name)}`
            const returnTypeName = property.isUnique ? `${pascalCase(entityDefinition.name)} | null` : `${pascalCase(entityDefinition.name)}[]`

            return `
          ${methodName} = async (${property.name}: string): PromisedResult<${returnTypeName}, UnknownRuntimeError> => {
            try {
              const scrollResult = await this.qdrantClient.scroll(this.qdrantCollectionName)
              const entities = scrollResult.points
                .map((point) => {
                  if (!point.payload) {
                    console.error(\`[VectorDb${pascalCase(entityDefinition.name)}Repository] ${methodName}: point.payload is null. Ignored \${point.id}\`)

                    return null
                  }

                  return this.isEntityType(point.payload) ? point.payload : null
                })
                .filter((entity): entity is ${pascalCase(entityDefinition.name)} => !!entity && entity.${camelCase(property.name)} === ${camelCase(property.name)})
              ${property.isUnique ? 'return Ok(entities[0] ?? null)' : 'return Ok(entities)'}
            } catch (e) {
              console.error(\`[VectorDb${pascalCase(entityDefinition.name)}Repository] ${methodName}: \${JSON.stringify(e)}\`)

              if (e instanceof Error) {
                return unknownRuntimeError(e.message)
              } else {
                return unknownRuntimeError(JSON.stringify(e))
              }
            }
          }
          `
          } else {
            return null
          }
        }),
      ).join('\n\n')}
    }
    `

    fs.writeFileSync(path.join(pathToOutputDirectory, `VectorDb${pascalCase(entityDefinition.name)}Repository.ts`), result)
  }
}

generateVectorDbRepositories().catch((error) => {
  console.error(error)
  process.exit(1)
})
