import path from 'path'
import fs from 'fs'
import pluralize from 'pluralize'
import { getEntityDefinitions } from 'ast-to-entity-definitions/bin/adapter/entry-points/function'
import { camelCase, pascalCase } from 'change-case'

export const generateEntityTypeWithAssociations = async () => {
  const pathToEntitiesDirectory = path.join(__dirname, '..', 'src', 'domain', 'entities')
  const pathToOutputDirectory = path.join(__dirname, '..', 'src', 'domain', 'entities', '_gen')

  if (!fs.existsSync(pathToOutputDirectory)) {
    throw new Error(`[generateEntityTypeWithAssociations] pathToOutputDirectory does not exist: ${pathToOutputDirectory}`)
  }
  // Delete all files in pathToOutputDirectory first
  fs.readdirSync(pathToOutputDirectory).forEach((file) => {
    fs.unlinkSync(path.join(pathToOutputDirectory, file))
  })

  const entityDefinitions = await getEntityDefinitions(pathToEntitiesDirectory)

  const identifiableEntities = entityDefinitions.filter((entityDefinition) => {
    return entityDefinition.properties.find((property) => property.name === 'id')
  })
  const nonIdentifiableEntities = entityDefinitions.filter((entityDefinition) => {
    return !entityDefinition.properties.find((property) => property.name === 'id')
  })

  console.log(
    'identifiableEntities',
    identifiableEntities.map((entityDefinition) => entityDefinition.name),
  )
  console.log(
    'nonIdentifiableEntities',
    nonIdentifiableEntities.map((entityDefinition) => entityDefinition.name),
  )

  for (const entityDefinition of entityDefinitions) {
    const uniqueReferrencingEntities = identifiableEntities.filter((candidateEntityDefinition) => {
      return candidateEntityDefinition.properties.find((property) => property.isReference && property.isUnique && property.targetEntityDefinitionName === entityDefinition.name)
    })
    const nonUniqueReferrencingEntities = identifiableEntities.filter((candidateEntityDefinition) => {
      return candidateEntityDefinition.properties.find((property) => property.isReference && !property.isUnique && property.targetEntityDefinitionName === entityDefinition.name)
    })
    const subTypeEntities = nonIdentifiableEntities.filter((candidateEntityDefinition) => {
      return candidateEntityDefinition.properties.find((property) => property.isReference && property.isUnique && property.targetEntityDefinitionName === entityDefinition.name)
    })

    console.log('====', entityDefinition.name)
    console.log(
      'uniqueReferrencingEntities',
      uniqueReferrencingEntities.map((entityDefinition) => entityDefinition.name),
    )
    console.log(
      'nonUniqueReferrencingEntities',
      nonUniqueReferrencingEntities.map((entityDefinition) => entityDefinition.name),
    )
    console.log(
      'subTypeEntities',
      subTypeEntities.map((entityDefinition) => entityDefinition.name),
    )

    const result = `// This file is generated by scripts/generateEntityTypeWithAssociations.ts
    import { ${pascalCase(entityDefinition.name)} } from '../${pascalCase(entityDefinition.name)}'
    // Referrencing entities
    ${[...uniqueReferrencingEntities, ...nonUniqueReferrencingEntities]
      .map((referencingEntity) => {
        return `import { ${pascalCase(referencingEntity.name)}WithAssociation } from './${pascalCase(referencingEntity.name)}WithAssociation'`
      })
      .join('\n')}
    // Sub type entities
    ${subTypeEntities
      .map((subTypeEntity) => {
        return `import { ${pascalCase(subTypeEntity.name)}WithAssociation } from './${pascalCase(subTypeEntity.name)}WithAssociation'`
      })
      .join('\n')}

    export type ${pascalCase(entityDefinition.name)}WithAssociation = ${pascalCase(entityDefinition.name)} & {
      // Unique Referrencing entities
      ${uniqueReferrencingEntities
        .map((referencingEntity) => {
          return `${camelCase(referencingEntity.name)}: ${pascalCase(referencingEntity.name)}WithAssociation`
        })
        .join('\n')}
      // Non-unique Referrencing entities
      ${nonUniqueReferrencingEntities
        .map((referencingEntity) => {
          return `${pluralize(camelCase(referencingEntity.name))}: ${pascalCase(referencingEntity.name)}WithAssociation[]`
        })
        .join('\n')}
      }${
        subTypeEntities.length > 0
          ? ` & (
          // Sub type entities
          ${subTypeEntities.reduce((acc, subTypeEntity) => {
            return `${acc} | ${pascalCase(subTypeEntity.name)}WithAssociation`
          }, '')}
        )`
          : ''
      }
    `

    fs.writeFileSync(path.join(pathToOutputDirectory, `${pascalCase(entityDefinition.name)}WithAssociation.ts`), result)
  }
}

generateEntityTypeWithAssociations().catch((error) => {
  console.error(error)
  process.exit(1)
})
